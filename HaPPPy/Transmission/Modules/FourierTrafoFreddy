#Def an command FT that calculates the discret fouriertransformation of an 
#function 'function' that is given on discret sampling points called 
#'arguments' (as well as the retransformation IFT). The result is a list of 
#complex numbers called'kFunction' ('xfunction) with a list of new samplepoints
#called 'new arguments'.
#ATTENTION!: the so called transformationmatrices TM and ITM are  matrices that
#perform a fourier transform (retransfomation) mod a normalizationfactor.
#This factor is recognised by the FT and IFT command.

import numpy
import cmath

def function(x):
    
    f = numpy.sin(x)+numpy.sin(2*x)
    
    return f

#inverse transformationmatrixelement
def ITMElement(arg,newArg):
    
    element = cmath.exp(1j*newArg*arg)/numpy.sqrt(N)
    
    return element

#FT transform to new arguments
def FT(xFunction):
    
    kFunction = L*numpy.dot(TM,xFunction)/numpy.sqrt(2*numpy.pi*N).real
    
    return kFunction

#IFT:retransform to arguments
def IFT(kFunction):
    
    xFunction = numpy.sqrt(2*numpy.pi*N)*numpy.dot(ITM,kFunction)/L
    
    return xFunction

########Constants and Parameters

L =  20#Range of arguments

N =  100 #Number of Arguments

x0 = -1 #lowest argument

k0 =  -10 #lowest new arguments

dx = L/N
dk = 2*cmath.pi/L
##########

#create transformationMatrices
indices = numpy.arange(0, N, 1) # indices of transformation matrices

#print(indices)

arguments = numpy.arange(x0, x0 + L, dx) #St√ºtzstellen of the fuction
#print(arguments)

newArguments = numpy.arange(k0,k0+N*dk, dk)
#print(newArguments)

ITM = numpy.zeros((N,N), dtype=numpy.complex64) #InverseTransformationMatrix
#print(matrix)

for n in indices: #rowindeces
    for m in indices: #columindices
        ITM[n][m] = ITMElement(arguments[n],newArguments[m])
#print(IFTM)

TM = numpy.transpose(ITM.conjugate()) #transformationsmatrix
#print(FTM)


##### Function that should be transformed
xfunction = [function(x) for x in arguments]
####

kfunction = FT(xfunction)
